using System;
using System.Collections.Generic;
using MongoDB.Bson;
using MongoDB.Bson.Serialization;

namespace Paralect.Domain.EventStore.Providers.MongoDB.Serialization
{
    public static class ChangesetSerializer
    {
        public static BsonDocument Serialize(Changeset changeset)
        {
            return new BsonDocument 
            {
                { "_id", changeset.ChangesetId },
                { "AggregateId", changeset.AggregateId },
                { "Version", changeset.Version },
                { "Events", EventsToBson(changeset.Events) },
            };
        }

        public static Changeset Deserialize(BsonDocument doc)
        {
            var groupId = doc["_id"].AsString;
            var eventArray = doc["Events"].AsBsonArray;
            var aggregateId = doc["AggregateId"].AsString;
            var version = doc["Version"].AsInt32;

            var events = new List<IEvent>();
            foreach (var eventValue in eventArray)
            {
                var eventDoc = eventValue.AsBsonDocument;

                // TODO: Here we should run event transformation engine on eventDoc to 
                // TODO: provide event versioning capabilities

                var metadataDoc = eventDoc["Metadata"].AsBsonDocument;
                var typeName = metadataDoc["TypeName"].AsString;

                // removing _t from metadata
                BsonElement t;
                if (metadataDoc.TryGetElement("_t", out t))
                    metadataDoc.RemoveElement(t);

                Type type = Type.GetType(typeName);

                if (type == null)
                    throw new Exception(String.Format("Cannot load this type: {0}. Make sure that assembly containing this type is referenced by your project.", typeName));

                IEvent e = (IEvent) BsonSerializer.Deserialize(eventDoc.ToBson(), type);
                events.Add(e);
            }

            var group = new Changeset(aggregateId, version, groupId, events);
            return group;
        }

        private static BsonArray EventsToBson(List<IEvent> events)
        {
            BsonArray array = new BsonArray();

            foreach (var e in events)
            {
                // Set CLR Type Name of events in metadata of each event
                if (String.IsNullOrEmpty(e.Metadata.TypeName))
                    e.Metadata.TypeName = e.GetType().AssemblyQualifiedName;

                var doc = e.ToBsonDocument();

                // Remove _t element if exists (generated by MongoDB driver)
                BsonElement t;
                if (doc.TryGetElement("_t", out t))
                    doc.RemoveElement(t);

/*                // Remove _t element in M if exists (generated by MongoDB driver)
                BsonElement t;
                if (doc.TryGetElement("_t", out t))
                    doc.RemoveElement(t);*/

                var json = doc.ToJson();
                array.Add(doc);
            }

            return array;
        }
    }
}
